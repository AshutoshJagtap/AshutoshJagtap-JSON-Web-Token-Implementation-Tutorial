# Implementation of JSON Web Token in .NET 5
<!-- TABLE OF CONTENTS -->
<details open="open">
  <summary>Table of Contents</summary>
  <ol>
    <li>
      <a href="#about-the-project">About The Project</a>
    </li>
    <li>
      <a href="#introduction-of-signing-algorithms">Introduction of Signing Algorithms</a>
    </li>
     <li>
      <a href="#introduction-of-refresh-token">Introduction of Refresh Token</a>
    </li>
  </ol>
</details>

<!-- ABOUT THE PROJECT -->
## About The Project

In this project we have implemented JSON Web Token Authentication in .Net 5.

There are 3 ways to create a token and for each way I have created separate branch.

Branches : 

* [Symmetric Encryption](https://github.com/AshutoshJagtap/JSON-Web-Token-Implementation-Tutorial/tree/main)
* [Asymmetric Encryption](https://github.com/AshutoshJagtap/JSON-Web-Token-Implementation-Tutorial/tree/Jwt-PrivatePublicKey)
* [Refresh Token](https://github.com/AshutoshJagtap/JSON-Web-Token-Implementation-Tutorial/tree/Jwt-RefreshToken)


According to below digram there are 3 main entities.

1. Authentication Broker :- 

      The **Authentication Broker** is responsible for generating token. In this project I have created [JWT.Authentication-Broker](https://github.com/AshutoshJagtap/JSON-Web-Token-Implementation-Tutorial/tree/main/JSON-Web-Token-Authentication/JWT.Authentication-Broker) project for the same.
      
2. Service  :-

     The **Service** is a responsible a validate a token before serving a request. In this project I have created [JWT.WebApi-Service](https://github.com/AshutoshJagtap/JSON-Web-Token-Implementation-Tutorial/tree/main/JSON-Web-Token-Authentication/JWT.WebApi-Service) project for the same.
      
3. Client :-

    The **Client** is a any platform which can able to call above mentioned services. In our case the client is [Postman](https://www.postman.com/).

![JWT Authentication.png](https://github.com/AshutoshJagtap/JSON-Web-Token-Implementation-Tutorial/blob/main/images/JWT%20Authentication.png)


<!-- INTRODUCTION OF SIGNING ALGORITHMS -->
## Introduction of Signing Algorithms

JSON Web Tokens are used in the industry more and more. The spec which defines them describes them as a compact, URL-safe means of representing claims between parties by encoding them as JSON objects which can be digitally signed or encrypted. There are several algorithms which take place in this process.

Common JWT Signing Algorithms
* HMAC + SHA256
* RSASSA-PKCS1-v1_5 + SHA256
* ECDSA + P-256 + SHA256

**HMAC algorithms**

This is **symmetric encryption** and digital signature algorithms  and probably the most common algorithm for signing JWTs.

Hash-Based Message Authentication Codes (HMACs) are a group of algorithms that provide a way of signing messages by means of a shared key. In the case of HMACs, a cryptographic hash function is used (for instance SHA256). The strength (i.e. how hard it is to forge an HMAC) depends on the hashing algorithm being used.

The main objective in the design of the algorithm was to allow the combination of a key with a message while providing strong guarantees against tampering. Ad-hoc solutions (for example, appending the key to the message and then hashing the result) suffer from mathematical flaws that allow potential attackers to forge the signature. The HMAC algorithm is designed against that.

HMACs are used with JWTs when you want a simple way for all parties to create and validate JWTs. Any party knowing the key can create new JWTs. In other words, with shared keys, it is possible for party to impersonate another one: HMAC JWTs do not provide guarantees with regards to the creator of the JWT. Anyone knowing the key can create one. For certain use cases, this is too permissive. This is where asymmetric algorithms come into play.

Symmetric cryptosystem (or private key cryptosystem) uses only one key for both encryption and decryption of the data. The key used for encryption and decryption is called the private key and only people who are authorized for the encryption/decryption would know it. In a symmetric cryptosystem, the encrypted message is sent over without any public keys attached to it. 

![symmetric encryption diagram.png](https://github.com/AshutoshJagtap/JSON-Web-Token-Implementation-Tutorial/blob/main/images/symmetric%20encryption%20diagram.png)


**RSA and ECDSA algorithms**

Both RSA and ECDSA are **asymmetric encryption** and digital signature algorithms. What asymmetric algorithms bring to the table is the possibility of verifying or decrypting a message without being able to create a new one. This is key for certain use cases. Picture a big company where data generated by the sales team needs to be verified by the accounting team. If an HMAC were to be used to sign the data, then both the sales team and the accounting team would need to know the same key. This would allow the sales team to sign data and make it pass as if it were from the accounting team. Although this might seem unlikely, especially in the context of a corporation, there are times when the ability to verify the creator of a signature is essential. JWTs signed or encrypted with RSA or ECDSA provide this capability. A party uses its private party to sign a JWT. Receivers in turn use the public key (which must be shared in the same way as an HMAC shared key) of that party to verify the JWT. The receiving parties cannot create new JWTs using the public key of the sender.

Both RSA and ECDSA algorithms are more complex than HMAC.

The main difference between RSA and ECDSA lies in speed and key size. ECDSA requires smaller keys to achieve the same level of security as RSA. This makes it a great choice for small JWTs. RSA, however, is usually faster than ECDSA.

![asymmetric encryption diagram.png](https://github.com/AshutoshJagtap/JSON-Web-Token-Implementation-Tutorial/blob/main/images/asymmetric%20encryption%20diagram.png)



<!-- INTRODUCTION OF REFRESH TOKEN -->
## Introduction of Refresh Token

**Refresh tokens** use for getting a new JWT token. A client may use a refresh token to get a new JWT token issued by the Authentication Broker. Common use cases include getting new JWT tokens after old ones have expired. Refresh tokens can also expire. Refresh tokens are usually subject to strict storage requirements to ensure they are not leaking. Refresh token is any sequence of characters which must be unique.
 
 Below are the steps:

1. When user is logs in, Authentication Broker will send 2 tokens (JWT token, Refresh token) in response to the client.

2. Authentication Broker will save Refresh token against the requested user in the database.

3. The JWT token will have less expiry time.

4. The client (Front end) will store refresh token in his local storage and JWT token in cookies.

5. The client will use an access token for calling APIs. But when it expires, pick the refresh token from local storage and call Authentication Broker to get the new token.

6. Authentication Broker will have an API exposed which will accept refresh token and checks for its validity and return a new access token.
